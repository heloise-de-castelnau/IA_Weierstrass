# -*- coding: utf-8 -*-
"""TestWeierstrass.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C6asUtJLPkZGE-YOX35COvCigf-WpN9z

On cherche d'abord à afficher le graphique de la fonction de weierstrass en fonction des valeurs qui nous été données dans le fichier csv
"""

# On importe les bibliothèques qui seront nécessaires à l'affichage de notre fonction
import pandas as pd
import csv

from google.colab import drive
drive.mount('/content/drive')

path='/content/drive/MyDrive/Data/temperature_sample.csv'
df = pd.read_csv(path, delimiter=";")

df = df.sort_values(by=['#i'],ascending=True) #on trie nos valeurs dans l'ordre croissant pour plus de visibilité
df

import matplotlib.pyplot as plt
import numpy as np

plt.xlabel('#i')
plt.ylabel('t')
plt.plot(df['#i'],df['t'])
plt.title('Weierstrass')
plt.legend()
plt.show()

# On crée les fonctions nécessaires à l'initialisation d'un individu et du calcul de son coût, utilité
import numpy as np
import random as rd
import math as mt

class Individu: 

    def __init__(self, a=None ,b=None, c=None):
        if (a==None or b==None or c==None) : 
            self.a = round(rd.random(),3)
            self.b = rd.randint(1,20)
            self.c = rd.randint(1,20)
        else :
            self.a = a
            self.b = b
            self.c = c

    
    def fitness(self):
      fitness =0
      for index in range(0,20):
        we=0
        for n in range(self.c+1):
          we+= (self.a**n)*mt.cos((self.b**n)*mt.pi*(df['#i'][index]))
        fitness += abs(df['t'][index]-we)  
      return round(fitness/20,3)



    def afficherIndividu(self) : #utile pour l'affichage des meilleures valeurs de a b et c qu'on garde à la fin
        affichage = str(self.a) + ";" + str(self.b) + ";" + str(self.c) 
        return affichage

def croisement(ind1 ,ind2) :

  new_ind1_croise = Individu(ind1.a, ind2.b, ind1.c)
  new_ind2_croise = Individu(ind2.a, ind1.b, ind2.c)
  
  return [new_ind1_croise, new_ind2_croise]

def mutation(ind):

  aleat = rd.randint(1,12)

  if (aleat <5) :
    ind.a = round(rd.random(),3)
  elif (aleat >8) :
    ind.b = rd.randint(1,20)
  else:
    ind.c = rd.randint(1,20)
  return ind

#On peut enfin initialiser une population d'individus et mesurer leurs coût individuellement afin de sélectionner les individues les plus pertinents
class Population:

  def __init__(self,count,liste = None): 
    self.count = count
    if liste != None:
          self.liste = liste
    else:
          self.liste = [] 
          for i in range(count):
                ind = Individu()
                self.liste.append(ind)  
  
 

  def afficherPopulation(self) : 
    for i in self.liste :
       print("{} coûte {}".format(i.afficherIndividu(), i.fitness()))

  def  getitems(self):
    return self.liste

  def substitution(self,autrepop):
  
    for i in range(0,len(self.liste)-1) :
        self.liste[i]=autrepop[i]


  
def valeur_population(pop) : 
   pop.liste = sorted(pop.liste, key = lambda ind : ind.fitness())
   #return Population(len(popSorted),popSorted)             

def addpopulation(self,pop2):
    newpop =self.liste +pop2.liste
    new_ind=self.count+pop2.count
    return Population(new_ind,newpop)    
        
#on print alors les différents induvidus obtenus en random et leur cout associé, il nous faut alors effectuer cette etape plusieurs fois 
#afin de sélectionner les meilleurs indivus c'est à dire ceux avec la fitness la plus proche de zéro

pop = Population(20)
pop.afficherPopulation()
print("Trie now")
valeur_population(pop)
pop.afficherPopulation()

def selection(pop,hcount,lcount):
    
    liste1=pop.liste[:hcount]
    liste2=pop.liste[-lcount:]
    return Population(len(liste1)+len(liste2),liste1 + liste2)

import random as rd
#code de la métode
def ExecutionFinale():
 pop= Population(35)
 
 valeur_population(pop)
 valeur_trouve= False
 compteur_générations=0
 while valeur_trouve == False:
   if (pop.getitems()[0].fitness()<=0.05):
     
     valeur_trouve = True
     print(pop.getitems()[0].afficherIndividu())
    #  print(pop.getitems()[0].fitness())
    #  print('Duration: {}'.format(end_time - start_time))
    #  print('Nombre de générations nécessaires: {}'.format(compteur_générations))
   else :
     compteur_générations+=1
     select=selection(pop,10,4)
     croises=[]
     for i in range(0,select.count,2):
          croises+= croisement(select.liste[i],select.liste[i+1])
      
     mutes=[] 
     for i in range(0,select.count):
          
          mutes.append(mutation(select.liste[i]))
      
          
      
     croimut=Population(len(mutes)+len(croises),mutes+croises)
     

     newalea=Population(5)
     pop_interm=addpopulation(newalea,croimut)
     pop= addpopulation(select,pop_interm)
     valeur_population(pop)
     
    #  print('Nombre de générations nécessaires: {}'.format(compteur_générations))
    #  print(pop.getitems()[0].afficherIndividu())
    #  print(pop.getitems()[0].fitness())
   

ExecutionFinale()